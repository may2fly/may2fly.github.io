---
layout: post
title: 从0开始学架构
categories: 读书笔记
---
# 架构是什么

## 系统与子系统

> 系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。
> 子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。

## 模块与组件
模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。
从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。

> 软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。

> 软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。


划分模块的主要目的是职责分离；划分组件的主要目的是单元复用。

## 框架与架构
> 软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。


框架关注的是“规范”，架构关注的是“结构”。

软件架构指软件系统的顶层结构；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。
> 首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。
> 其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。


# 架构设计的历史背景
软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。

软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的“拆分”方法论，软件架构是一种对软件的“组织”方法论。一分一合，其目的是为了软件研发过程中的成本、进度、质量得到有效控制。
一个成功的软件设计是要适应并满足业务需求，同时不断“演化”的。设计需要根据业务的变化、技术的发展不断进行“演进”，这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的“一招鲜”。

结构化程序设计：采取“自顶向下、逐步细化、模块化”的指导思想。
面向对象编程：“对象”
“软件架构”：“组件”

# 架构设计的目的
架构设计的主要目的是为了解决软件系统复杂度带来的问题。

架构即(重要)决策，是在一个有约束的盒子里去求解或接近最合适的解。

需求驱动架构。

1 架构是为了应对软件系统复杂度而提出的一个解决方案。
2 架构即(重要)决策
3 需求驱动架构，架起分析与设计实现的桥梁
4 架构与开发成本的关系

## 复杂度来源：高性能
软件系统中高性能带来的复杂度主要体现在两方面：
> 一方面是单台计算机内部为了高性能带来的复杂度；
> 另一方面是多台计算机集群为了高性能带来的复杂度。

### 单机复杂度
一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点

### 集群的复杂度
让多台机器配合起来达到高性能的目的，是一个复杂的任务.
垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实性能的提升。
1. 任务分配
2. 任务分解
* 简单的系统更加容易做到高性能
* 可以针对单个任务进行扩展

## 复杂度来源：高可用
高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。
### 计算高可用
### 存储高可用
>  存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。
> 储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，

## 复杂度来源：可扩展性
预测变化——>应对变化

## 复杂度来源：低成本、安全、规模

# 架构设计三原则
合适原则、简单原则、演化原则
* 合适原则宣言：“合适优于业界领先”
* 简单原则宣言：“简单优于复杂”。
> 软件领域的复杂性体现在：结构的复杂性；逻辑的复杂性
* 演化原则宣言：“演化优于一步到位”。
> 对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。

# 架构设计流程
架构设计的本质目的是为了解决软件系统的复杂性。

## 1、架构设计流程：识别复杂度
将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。
（1）构建复杂度的来源清单——高性能、可用性、扩展性、安全、低成本、规模等。
（2）结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要？是否关键？
（3）按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就越关键，就越优先解决。

## 2、架构设计流程：设计备选方案
* 备选方案的数量以 3 ~ 5 个为最佳。
* 备选方案的差异要比较明显。
* 备选方案的技术不要只局限于已经熟悉的技术。

备选阶段关注的是技术选型，而不是技术细节，技术选型的差异要比较明显。

## 3、架构设计流程：评估和选择备选方案
“360 度环评”：列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。

方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。

按优先级选择，即架构师综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序

## 4、架构设计流程：详细方案设计
详细方案设计就是将方案涉及的关键技术细节给确定下来。

* 架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解。
* 通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度
* 果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长

# 高性能数据库集群
高性能数据库集群的第一种方式是“读写分离”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。

## 1、高性能数据库集群：读写分离
读写分离的基本原理是将数据库读写操作分散到不同的节点上。基本实现是：
* 数据库服务器搭建主从集群，一主一从、一主多从都可以。
* 数据库主机负责读写操作，从机只负责读操作。
* 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
* 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

主从复制延迟：写操作后的读操作指定发给数据库主服务器；读从机失败后再读一次主机；关键业务读写操作全部指向主机，非关键业务采用读写分离
分配机制：将读写操作区分开来，然后访问不同的数据库服务器，采取方式为程序代码封装和中间件封装。

## 2、高性能数据库集群：分库分表
业务分库指的是按照业务模块将数据分散到不同的数据库服务器。

将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。

单表数据拆分有两种方式：垂直分表和水平分表。
* 垂直分表：适合将表中某些不常用且占了大量空间的列拆分出去。
* 水平分表：适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表

水平分表相比垂直分表的复杂度表现在：路由(Hash 路由、配置路由)、join 操作、count() 操作、order by 操作


# 高性能
## 1、高性能NoSQL

关系数据库缺点：
* 关系数据库存储的是行记录，无法存储数据结构
* 关系数据库的 schema 扩展很不方便
* 关系数据库在大数据场景下 I/O 较高
* 关系数据库的全文搜索功能比较弱

常见的 NoSQL 方案分为 4 类。
* K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。
* 文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。
* 列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。
* 全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表。


## 高性能缓存架构
缓存穿透是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。

缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况。常见解决方法有两种：更新锁机制和后台更新机制。

缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。

## 单服务器高性能模式
### 单服务器高性能模式：PPC与TPC
高性能架构设计主要集中在两方面：
* 尽量提升单服务器的性能，将单服务器的性能发挥到极致。
* 如果单服务器无法支撑性能，设计服务器集群方案。

单服务器高性能的关键之一就是服务器采取的并发模型：
* 服务器如何管理连接。
* 服务器如何处理请求。

PPC 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求。
prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。

TPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。
prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。

### 单服务器高性能模式：Reactor与Proactor
单服务器高性能架构模式：Reactor 和 Proactor。

Reactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。
Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。

Reactor 可以理解为“来了事件我通知你，你来处理”，而 Proactor 可以理解为“来了事件我来处理，处理完了我通知你”。


## 高性能负载均衡
高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。

## 高性能负载均衡：分类及架构
负载均衡分类：
* DNS负载均衡：DNS 解析同一个域名可以返回不同的 IP 地址
* 硬件负载均衡：通过单独的硬件设备来实现负载均衡功能。
* 软件负载均衡：通过负载均衡软件来实现负载均衡功能，如 Nginx 和 LVS

软件和硬件的最主要区别就在于性能，硬件负载均衡性能远远高于软件负载均衡性能。

DNS 负载均衡用于实现地理级别的负载均衡；硬件负载均衡用于实现集群级别的负载均衡；软件负载均衡用于实现机器级别的负载均衡。

### 高性能负载均衡：算法

* 任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理
* 负载均衡类：负载均衡系统根据服务器的负载来进行分配，指标：CPU负载、连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。
* 性能最优类：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。
* Hash 类：负载均衡系统根据任务中的某些关键信息进行 Hash运算，将相同 Hash 值的请求分配到同一台服务器上。

轮询：负载均衡系统收到请求后，按照顺序轮流分配到服务器上。
加权轮询：根据服务器权重进行任务分配。权重设置有静态和动态
负载最低优先：将任务分配给当前负载最低的服务器
性能最优类：将任务分配给处理速度最快的服务器，通过这种方式达到最快响应客户端的目的。
Hash 类：将相同 Hash 值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。

## 高可用存储架构
存储高可用方案的本质都是通过将数据复制到多个存储设备，通过数据冗余的方式来实现高可用。

常见的高可用存储架构有主备、主从、主主、集群、分区

### 高可用存储架构：双机架构
常见的双机高可用架构：主备、主从、主备 / 主从切换和主主。

* 主备复制：主备架构中的“备机”主要还是起到一个备份作用，并不承担实际的业务读写操作
* 主从复制：主机负责读写操作，从机只负责读操作，不负责写操作。

双机切换架构：
互连式：主备机直接建立状态传递的渠道
中介式：主备机通过中介来传递状态信息
模拟式：备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。

主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作。

### 高可用存储架构：集群和分区
集群可以分为两类：数据集中集群、数据分散集群。

* 数据集中集群：主机如何将数据复制给备机、备机如何检测主机状态、主机故障后，如何决定新的主机
* 数据分散集群的复杂点在于如何将数据分配到不同的服务器上，关注点：均衡性、容错性、可伸缩性

数据分区指将数据按照一定的规则进行分区，不同分区分布在不同的地理位置上，每个分区存储一部分数据，通过这种方式来规避地理级别的故障所造成的巨大影响。
* 数据量：数据量越大，分区规则会越复杂，考虑的情况也越多。
* 分区规则：地理位置有近有远，因此可以得到不同的分区规则
* 复制规则：集中式、互备式和独立式。


# 如何设计计算高可用架构？
计算高可用架构的设计复杂度主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。
* 哪些服务器可以执行任务？
* 任务如何重新执行？

常见的计算高可用架构：主备、主从和集群。
* 主备架构是计算高可用最简单的架构，和存储高可用的主备复制架构类似。分为冷备架构和温备架构。
* 计算高可用的主从架构中的从机也是要执行任务的
* 根据集群中服务器节点角色的不同，分为：对称集群和非对称集群
> 对称集群更通俗的叫法是负载均衡集群
> 非对称集群中不同服务器的角色是不同的，不同角色的服务器承担不同的职责。

## 业务高可用的保障

### 业务高可用的保障：异地多活架构
异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方。多活就是指不同地理位置上的系统都能够提供业务服务。

根据地理位置上的距离来划分，异地多活架构可以分为同城异区、跨城异地、跨国异地。

* 优先实现核心业务的异地多活架构！
* 保证核心数据最终一致性
* 采用多种手段同步数据
* 只保证绝大部分用户的异地多活

异地多活设计的理念总结为一句话：采用多种手段，保证绝大部分用户的核心业务异地多活！

跨城异地多活架构设计的 4 个步骤：
1、业务分级
> 按照一定的标准将业务进行分级，挑选出核心的业务，只为核心业务设计异地多活。常见的分级标准：访问量大的业务、核心业务、产生大量收入的业务
2、数据分类
> 识别所有的数据及数据特征，这些数据特征会影响后面的方案设计。数据特征分析维度:数据量、唯一性、实时性、可丢失性、可恢复性
3、数据同步
> 根据不同的数据设计不同的同步方案。常见同步方案：存储系统同步、消息队列同步、重复生成
4、异常处理
> 无论数据同步方案如何设计，一旦出现极端异常的情况，总是会有部分数据出现异常的。异常处理措施:多通道同步、同步和访问结合、日志记录、用户补偿

## 如何应对接口级的故障？
导致接口级故障的原因：
* 内部原因：bug，数据查询慢
* 外部原因:黑客攻击、超高峰访问

解决接口级故障的核心思想：优先保证核心业务和优先保证绝大部分用户。

降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。

熔断的目的是应对依赖的外部系统故障的情况。

限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。

排队是让用户等待一段时间。由于排队需要临时缓存大量的业务请求,需要用独立的系统去实现。


# 可扩展架构
架构可扩展模式，包括分层架构、SOA 架构、微服务和微内核等

## 可扩展架构的基本思想和模式
所有的可扩展性架构设计，基本思想：拆！将原本大一统的系统拆分成多个规模小的部分

按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种：
* 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。
* 面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。
* 面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。

流程 > 服务 > 功能
不同的拆分方式，本质上决定了系统的扩展方式。
* 面向流程拆分：分层架构。扩展时大部分情况只需要修改某一层，少部分情况可能修改关联的两层
* 面向服务拆分：SOA、微服务。对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务。
* 面向功能拆分：微内核架构。对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务。


## 传统的可扩展架构模式：分层架构和SOA
按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。
* C/S 架构、B/S 架构：划分的对象是整个业务系统，划分的维度是用户交互
* MVC 架构、MVP 架构：划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。
* 逻辑分层架构：划分的维度是职责，分层是自顶向下依赖的。

需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构。

隔离关注点每个层中的组件只会处理本层的逻辑。分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。

对于操作系统这类复杂的系统，接口本身也可以成为独立的一层。

分层架构的优势就体现在通过分层强制约束两两依赖，一旦分层确定，整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃。


SOA即“面向服务的架构”，关键概念：
* 服务：服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。
* ESB 的全称是 Enterprise Service Bus：将企业中各个不同的服务连接在一起。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。
* 松耦合：目的是减少各个服务间的依赖和互相影响。

SOA 解决了传统 IT 系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。

## 深入理解微服务架构

SOA 时候提到其产生历史背景是因为企业的 IT 服务系统庞大而又复杂，改造成本很高，但业务上又要求其互通。
SOA和微服务本质上是两种不同的架构设计理念，只是在“服务”这个点上有交集而已。

实施微服务额陷阱：
* 微服务拆分过细，过分强调“small”。
* 微服务基础设施不健全，忽略了“automated”
* 微服务并不轻量级，规模大了后，“lightweight”不再适应。

服务粒度:一个微服务三个人负责开发。系统的复杂度刚好达到每个人都能全面理解整个系统，又能够进行分工的粒度。主要应用于微服务设计和开发阶段
拆分方法：基于“三个火枪手”的理论，我们可以计算出拆分后合适的服务数量。
> 1. 基于业务逻辑拆分
> 2. 基于可扩展拆分：稳定服务和变动服务
> 3. 基于可靠性拆分：将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用
> 4. 基于性能拆分：将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。

微服务基础设施：
1. 服务发现、服务路由、服务容错：这是最基本的微服务基础设施。
2. 接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。
3. 自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。
4. 服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。

**自动化测试** 
> 自动化测试涵盖的范围包括代码级的单元测试、单个系统级的集成测试、系统间的接口测试，理想情况是每类测试都自动化。
**自动化部署**
> 自动化部署系统包括版本管理、资源管理（例如，机器管理、虚拟机管理）、部署操作、回退操作等功能。
**配置中心**
> 配置中心包括配置版本管理、增删改查配置、节点管理、配置同步、配置推送等功能。
**接口框架**
> 微服务提倡轻量级的通信方式，一般采用 HTTP/REST或者 RPC 方式统一接口协议,还需要统一接口传递的数据格式
**API 网关**
> 系统拆分为微服务后，内部的微服务之间是互联互通的，相互之间的访问都是点对点的。微服务需要一个统一的 API 网关，负责外部系统的访问操作。
> API 网关是外部系统访问的接口，所有的外部系统接⼊系统都需要通过 API 网关，主要包括接入鉴权（是否允许接入）、权限控制（可以访问哪些功能）、传输加密、请求路由、流量控制等功能。
**服务发现**
> 服务发现主要有两种实现方式：自理式和代理式。
> 自理式结构就是指每个微服务自己完成服务发现。
> 代理式结构就是指微服务之间有一个负载均衡系统，由负载均衡系统来完成微服务之间的服务发现。
服务发现的核心功能就是服务注册表，注册表记录了所有的服务节点的配置和状态，每个微服务启动后都需要将自己的信息注册到服务注册表，然后由微服务或者 LOAD BALANCER 系统到服务注册表查询可用服务。

**服务路由**
>从所有符合条件的可用微服务节点中挑选出一个具体的节点发起请求
>常见的路由算法有：随机路由、轮询路由、最小压力路由、最小连接数路由等。

**服务容错**
> 常见的服务容错包括请求重试、流控和服务隔离。

**服务监控**
> 服务监控需要搜集并分析大量的数据，因此建议做成独立的系统。服务监控的主要作用有：
> * 实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间
> * 服务监控可以在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低了问题影响的范围和时间。

**服务跟踪**
> 服务监控和服务跟踪的区别可以简单概括为宏观和微观的区别。

**服务安全**
> 服务安全主要分为三部分：接入安全、数据安全、传输安全。
> 服务安全可以集成到配置中心系统中进行实现，即配置中心配置微服务的接入安全策略和数据安全策略，微服务节点从配置中心获取这些配置信息，然后在处理具体的微服务调用请求时根据安全策略进行处理。

## 微内核架构详解
微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。

微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。

* 插件管理：插件注册表机制。核心系统提供插件注册表，插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。
* 插件连接：核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。
* 插件通信：由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。

规则引擎从结构上来看也属于微内核架构的一种具体实现，其中执行引擎可以看作是微内核，执行引擎解析配置好的业务流，执行其中的条件和规则，通过这种方式来支持业务的灵活多变。

规则引擎却能够很灵活的应对业务的复杂多变，主要原因在于：
* 可扩展：业务逻辑实现与业务系统分离，可以在不改动业务系统的情况下扩展新的业务功能。
* 易理解：规则通过自然语言描述
* 高效率：提供可视化的规则定制、审批、查询及管理，方便业务人员快速配置新的业务。


# 技术架构演进

## 架构师应该如何判断技术演进的方向？
1. 潮流派
> 对于新技术特别热衷，紧跟技术潮流，当有新的技术出现时，迫切想将新的技术应用到自己的产品中。
2. 保守派
> 对于新技术抱有很强的戒备心，稳定压倒一切，已经掌握了某种技术，就一直用这种技术打天下。
3. 跟风派
> 判断技术的发展就看竞争对手，竞争对手用了咱们就用，竞争对手没用咱们就等等看。

产品类业务：技术创新推动业务发展！用户选择一个产品的根本驱动力在于产品的功能是否能够更好地帮助自己完成任务。
“服务”类业务：业务发展推动技术的发展！用户选择一个服务的根本驱动力不是功能，而是“规模”。

基于业务发展阶段进行判断业务当前和接下来一段时间的主要复杂度是什么。

## 互联网技术演进的模式
互联网业务发展一般分为几个时期：初创期、发展期、竞争期、成熟期。

* 业务复杂性：互联网业务发展第一个主要方向就是“业务越来越复杂”
> 1. 初创期:初创期的业务对技术就一个要求：“快”
> 2. 发展期:核心工作是快速地实现各种需求，满足业务发展的需要。主要可分为：堆功能期、优化期、架构期
> 3. 竞争期：系统数量的量变带来了技术工作的质变
> 平台化:在于解决“重复造轮子”的问题。如存储平台化、数据库平台化、缓存平台化
> 服务化:在于解决“系统交互”的问题，常见的做法是通过消息队列来完成系统间的异步通知，通过服务框架来完成系统间的同步调用。如消息队列、服务框架
> 4. 成熟期：主要工作优化

* 用户规模：互联网业务的发展第二个主要方向就是“用户量越来越大”。
> 用户量增大对技术的影响主要体现在两个方面：性能要求越来越高、可用性要求越来越高。

## 互联网架构模板：“存储层”技术
* SQL
* NoSQL
> 统一存储平台主要实现这几个功能:
> * 资源动态按需动态分配
> * 资源自动化管理
> * 故障自动化处理
* 小文件存储
* 大文件存储

## 互联网架构模板：“开发层”和“服务层”技术
开发层技术
* 开发框架：优选成熟的框架，避免盲目追逐新技术！
* Web 服务器：成熟的开源 Web 服务器
* 容器：以 Docker 为代表

服务层技术：主要目标其实就是为了降低系统间相互关联的复杂度。
* 配置中心：集中管理各个系统的配置
* 服务中心：服务名字系统和服务总线系统。
* 消息队列
> 传统的异步通知方式是由消息生产者直接调用消息消费者提供的接口进行通知的
> 消息队列就是为了实现这种跨系统异步通知的中间件系统。消息队列既可以“一对一”通知，也可以“一对多”广播。

## 互联网架构模板：“网络层”技术
* 负载均衡：将请求均衡地分配到多个系统上。方式：DNS、Nginx 、LVS 、F5
* CDN：将内容缓存在离用户最近的地方，用户访问的是缓存的内容，而不是站点实时的内容。
* 多机房：多机房的主要目标是灾备。设计最核心的因素就是如何处理时延带来的影响。策略有：同城多机房、跨城多机房、跨国多机房
* 多中心：多中心设计的关键就在于“数据一致性”和“数据事务性”如何保证

## 互联网架构模板：“用户层”和“业务层”技术
用户层技术
1. 用户管理
> 单点登录（SSO）：CAS架构实现、授权登录：OAuth协议实现
2. 消息推送
> 消息推送根据不同的途径，分为短信、邮件、站内信、App 推送。
3. 存储云、图片云

业务层技术
业务层面对的主要技术挑战是“复杂度”。将整体复杂性分散到多个子业务或者子系统里面去。

采取的“合”的方式是按照“高内聚、低耦合”的原则，将职责关联比较强的子系统合成一个虚拟业务域，然后通过网关对外统一呈现。

## 互联网架构模板：“平台”技术
### 运维平台
运维平台核心的职责分为四大块：配置、部署、监控、应急，每个职责对应系统生命周期的一个阶段。
* 配置：主要负责资源的管理。例如，机器管理、IP 地址管理、虚拟机管理等。
* 部署：主要负责将系统发布到线上。例如，包管理、灰度发布管理、回滚等。
* 监控：主要负责收集系统上线运行后的相关数据并进行监控，以便及时发现问题。
* 应急：主要负责系统出故障后的处理。例如，停止程序、下线故障机器、切换 IP 等。

运维平台的核心设计要素是“四化”：标准化、平台化、自动化、可视化。
1. 标准化：制定运维标准，规范配置管理、部署流程、监控指标、应急能力等准化是运维平台的基础，没有标准化就没有运维平台。
2. 平台化：运维的相关操作都集成到运维平台中，通过运维平台来完成运维工作。
3. 自动化：将重复操作固化下来，由系统自动完成。
4. 可视化：可视化的主要目的就是为了提升数据查看效率。

### 测试平台
测试平台核心的职责包括单元测试、集成测试、接口测试、性能测试等。

测试平台的核心目的是提升测试效率，从而提升产品质量，其设计关键就是自动化。
1. 用例管理：测试自动化的主要手段就是通过脚本或者代码来进行测试。测试平台需要将用例管理起来，管理的维度包括业务、系统、测试类型、用例代码。
2. 资源管理：使用虚拟技术来充分利用硬件资源，如虚拟机、Docker 等技术。
3. 任务管理：将测试用例分配到具体的资源上执行，跟踪任务的执行情况。
4. 数据管理：测试任务执行完成后，需要记录各种相关的数据。

### 数据平台
数据平台的核心职责主要包括三部分：数据管理、数据分析和数据应用。
1. 数据管理：包含数据采集、数据存储、数据访问和数据安全四个核心职责，是数据平台的基础功能。
> 数据采集：从业务系统搜集各类数据。
> 数据存储：将从业务系统采集的数据存储到数据平台，用于后续数据分析。
> 数据访问：负责对外提供各种协议用于读写数据。
> 数据安全：部分业务敏感数据需要加以保护，防止被其他业务读取甚至修改
2. 数据分析：包括数据统计、数据挖掘、机器学习、深度学习等几个细分领域。
> 数据统计：根据原始数据统计出相关的总览数据。
> 数据挖掘：指传统的数据挖掘方式
> 机器学习、深度学习：
3. 数据应用：数据应用很广泛，既包括在线业务，也包括离线业务。

### 管理平台
管理平台的核心职责就是权限管理，权限管理主要分为两部分：身份认证、权限控制。
1. 身份认证：确定当前的操作人员身份，防止非法人员进入系统。
2. 权限控制：根据操作人员的身份确定操作权限，防止未经授权的人员进行操作。


# 架构重构

## 架构重构内功心法第一式：有的放矢
架构师的首要任务是从一大堆纷繁复杂的问题中识别出真正要通过架构重构来解决的问题，集中力量快速解决，而不是想着通过架构重构来解决所有的问题。

架构师需要透过问题表象看到问题本质，找出真正需要通过架构重构解决的核心问题，从而做到有的放矢，既不会耗费大量的人力和时间投入，又能够解决核心问题。

## 架构重构内功心法第二式：合纵连横
架构重构是大动作，持续时间比较长，而且会占用一定的研发资源，包括开发和测试，因此不可避免地会影响业务功能的开发。

上下游沟通，以事实说话，以数据说话。
系统内沟通，“换位思考、合作双赢、关注长期“

## 架构重构内功心法第三式：运筹帷幄
重构就是“分段实施”，将要解决的问题根据优先级、重要性、实施难度等划分为不同的阶段，每个阶段聚焦于一个整体的目标，集中精力和资源解决一类问题。
* 每个阶段都有明确目标，做完之后效果明显，团队信心足，后续推进更加容易。
* 每个阶段的工作量不会太大，可以和业务并行。
* 每个阶段的改动不会太大，降低了总体风险。

“分段实施”的策略有哪些：
1. 优先级排序：解决目前遇到的主要问题
2. 问题分类：将问题按照性质分类，每个阶段集中解决一类问题。
3. 先易后难
4. 循序渐进

不要重复发明轮子，但要找到合适的轮子！

# App架构的演进
架构设计理念：
* 架构是系统的顶层结构。
* 架构设计的主要目的是为了解决软件系统复杂度带来的问题。
* 架构设计需要遵循三个主要原则：合适原则、简单原则、演化原则。
* 架构设计首先要掌握业界已经成熟的各种架构模式，然后再进行优化、调整、创新。

1. Web App
Web App 架构又叫包壳架构，简单来说就是在 Web 的业务上包装一个 App 的壳，业务逻辑完全还是 Web 实现，App 壳完成安装的功能
2. 原生 App
随着业务发展和技术演进，移动开发的复杂度从“快速开发”和“低成本”转向了“用户体验”，而要保证用户体验，采用原生 App 的架构是最合适的
3. Hybrid App
能够较好的平衡“用户体验”和“快速开发”两个复杂度问题
4. 组件化 & 容器化
基本思想都是将超级 App 拆分为众多组件，这些组件遵循预先制定好的规范，独立开发、独立测试、独立上线。
组件之间通过消息系统进行通信，通过这种方式来实现组件隔离，从而避免各个团队之间的互相依赖和影响，以提升团队开发效率和整个系统的可扩展性。
5. 跨平台 App
RN、Flutter